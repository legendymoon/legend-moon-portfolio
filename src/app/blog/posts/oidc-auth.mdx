---
title: "Why We Switched to OIDC for Service-to-Service Auth"
summary: "Static tokens got the job doneâ€”until they didn't. Here's how OIDC helped us fix brittle auth flows, simplify secret management, and scale internal service communication securely."
publishedAt: "2024-06-08"
tags: [ "Tech" ]
image: "/images/blog/tech-oidc-auth/cover.png"
---

![OIDC trust handshake visual](/images/blog/tech-oidc-auth/1.png)

## The Breaking Point

It started with a Slack alert about a failed internal API call. At first, we thought it was just a bad deploy. Then it happened again. And again.

The culprit? A **hardcoded bearer token** that had expired but was still in useâ€”across four services.

We realized we were running a system held together by a patchwork of static secrets and hopeful assumptions. It was time for a change.

---

## Auth Had Become a Liability

Letâ€™s break down what we were dealing with:

- ğŸ”’ Secrets scattered in config files and CI pipelines.
- ğŸ¤ No handshakeâ€”just "hereâ€™s a token, trust me."
- ğŸ” Manual token rotation during late-night hotfixes.
- ğŸ“‰ No visibility into who was calling what and why.

Every new microservice added more complexity. And more risk.

---

## Enter OIDC

We didnâ€™t want to reinvent the wheel. We wanted something battle-tested, standards-based, and flexible.  
OpenID Connect (OIDC) gave us:

- Short-lived **JWTs** with verifiable claims
- **Centralized issuance** and automatic expiry
- Support for the **Client Credentials Flow** (ideal for service-to-service)
- **JWKS** endpoints for public-key-based validation

Most importantly, it let us enforce *identity, access, and trust* â€” not just possession of a shared secret.

---

## What Changed Under the Hood

We defined every service as a client with a unique ID and secret in our IdP (Auth0). When `Service A` needed to talk to `Service B`, it would:

1. Exchange its credentials for a token scoped to `Service B`.
2. Send the token with its requests.
3. `Service B` would validate it using the IdPâ€™s public JWKS URL.

<CodeBlock
  codeInstances={[
    {
      code:
        `POST /oauth/token

{
  "grant_type": "client_credentials",
  "client_id": "svc-a",
  "client_secret": "...",
  "audience": "svc-b"
}`,
      language: "http",
      label: "Token request"
    }
  ]}
/>

No shared secrets. No manual rotation. No guesswork.

---

## Surprises Along the Way

This shift wasnâ€™t pain-free. Some lessons hit us early:

- ğŸ”„ **Token expiration hurts** if your service doesnâ€™t retry properly.
- ğŸ” **Caching JWKS** is mandatoryâ€”fetching it on every request is a footgun.
- âš ï¸ **Browser-incompatible flows** meant we kept REST tokens for frontend APIs.
- ğŸ§© **Scope naming is architecture**. A good naming scheme for scopes avoids spaghetti permissions later.

Still, it was a massive upgrade.

---

![JWT lifecycle and trust chain](/images/blog/tech-oidc-auth/2.jpg)

---

## The Real Payoff

Today, our service-to-service auth:

- ğŸ¯ Is **zero-trust** by designâ€”every call is validated
- ğŸ” Is **auditable**â€”we know who called what, and when
- ğŸ”„ Is **rotated** every hour, automatically
- ğŸ”§ Is **enforced** with a shared middleware across Node, Go, and Python services

We sleep better now.

---

## Not Just Secureâ€”Clean

One of the biggest wins wasnâ€™t even security. It was **clean architecture**.

By tying identity to services instead of secrets, we made ownership, responsibility, and access explicit. It became obvious which services needed which privilegesâ€”and which didnâ€™t.

If you're still passing around long-lived tokens like backstage passes, you might want to ask: _what happens if one of them leaks?_

---

## TL;DR

- Static tokens were fineâ€¦ until we scaled.
- OIDC gave us rotating, verifiable, scoped tokens.
- We now trust identity, not possession.
- Itâ€™s been the single best infrastructure upgrade weâ€™ve made in the past year.